'use strict';

//filesystem access
var fs = require('fs');
//dateformat library
var dateFormat = require('dateformat');

//constants
var CONTROLLER_PORT = 50555; //websocketport on which the devices (actors/sensors) communicate
var DATA_PORT = 50556; //websocketport in which the clients (e.g. Webbrowser, Android-Phone) communicate
var LOGFILE_PATH = __dirname + "/" + "log.txt" //logfile path
var CONFIGURATIONS_PATH = __dirname + "/" + "configurations.json"; //where the configurations.json file gets saved
var AUTOMATIC_DISCONNECT_DEVICE_TIME = 25; //time which a device has to reconnect in seconds before being automatically disconnected
var TIMER_INTERVAL_FORCE_DATA = 5000; //the interval in milliseconds in which the server forces a device to send data
var DATABASE_PATH = __dirname + "/" + "DataLog.db"; //database path

//initializing the webSocketServers
var WebSocketServer = require('ws').Server,
  controllerWSS = new WebSocketServer({
    port: CONTROLLER_PORT
  }),
  dataWSS = new WebSocketServer({
    port: DATA_PORT
  });

//global variables
//initialize devices array
var devices = [];
//initialze configurations array
var configurations = [];

var ind = 0;
//------------------------- LOGGING -------------------------
//params - text: the logtext to be saved, level: the loglevel [info, error]
//returns -
//functionality - saves the specified values into the logfile with a formatted
//                timestamp
var flog = function(text, level) {

  var newLog = '[' + level + ']' + '[' + dateFormat(new Date(),
    'dd-mm-yyyy hh:MM:ss TT') + ']' + text + '\n';
  var logs;
  fs.appendFile(LOGFILE_PATH, newLog, function(err, data) {
    if (err)
      console.log(err);
  });


};

flog('server started', 'INFO');

//------------------------- CONFIGURATIONS -------------------------


//reads all configurations into the configurations array
fs.readFile(CONFIGURATIONS_PATH, 'utf8', function(err, data) {
  try {
    configurations = JSON.parse(data);
    flog("loaded configurations file", "INFO");
  } catch (e) {
    flog("could not read configurations file", "ERROR");
    return;
  }
});

//params - newConfig: new configuration to be added
//returns -
//functionality - pushes the new config in the array and saves it to the configurations file
var addConfiguration = function(newConfig) {
  configurations.push(newConfig);

  writeConfigsToFile();
  flog("added configuration " + newConfig.cname, "INFO");
};


//params - toDelete: configuration deleted
//returns -
//functionality - deletes the specified configuration from the array and saves it to the configurations file
var deleteConfiguration = function(toDelete) {
  for (var i = 0; i < configurations.length; i++) {
    if (configurations[i].cname === toDelete) {
      configurations.splice(i, 1);
      writeConfigsToFile();
      flog("deleted configuration " + toDelete, "INFO");
    }
  }

};

//params -
//returns -
//functionality - saves all the current configurations to the configurations file
var writeConfigsToFile = function() {

  cleanupConfigurations();

  fs.writeFile(CONFIGURATIONS_PATH, JSON.stringify(
    configurations), function(err) {
    if (err) {
      return console.log(err);
    }

    flog("wrote new configurations to file", "INFO");
  });
};

//params -
//returns -
//functionality - cleans up the conditions for $$hashKey attributes which are generated by using a nested ng-repeat
var cleanupConfigurations = function() {
  for (var i = 0; i < configurations.length; i++) {
    for (var j = 0; j < configurations[i].conditions.length; j++) {
      delete configurations[i].conditions[j].$$hashKey;
    }
  }
};
//params - cname: config to be found
//returns - index of specified configuration in configurations array
//functionality - finds the index of the specified configuration
var findConfigurationByName = function(cname) {
  for (var i = 0; i < configurations.length; i++) {
    if (configurations[i].cname === cname) return i;
  }
  return -1;
};

//params - cname: configuration to be edited, newConfig: the new configuration
//returns -
//functionality - replaces the specified configuration with newConfig
var editConfiguration = function(cname, newConfig) {
  configurations[findConfigurationByName(cname)] = newConfig;
  writeConfigsToFile();
  flog('configuration edited: ' + cname, 'INFO');
};

//params - cname: configuration to be checked
//returns - true if configuration already exists, false if it doesn't
//functionality - searches the configurations file for a possible match
var configNameAlreadyExists = function(cname) {
  for (var i = 0; i < configurations.length; i++) {
    if (configurations[i].cname === cname)
      return true;
  }
  return false;
};

//------------------------- DEVICES -------------------------
//initialize time as a device
devices.push({
  type: "time",
  category: "sensor",
  dname: "time",
  values: "date",
  ip: null,
  latestValue: null

});

//params - dname: device to be found
//returns - ip: ip of the device
//functionality - looks for the specified device and returns its ip
var getIpForDname = function(dname) {

  for (var i = 0; i < devices.length; i++) {
    if (devices[i].dname === dname)
      return devices[i].ip;
  }
  return -1;
};

//params - dname
//returns -
//functionality - searches for the specified device and deletes it
var deleteDeviceByDname = function(dname) {
  for (var i = 0; i < devices.length; i++) {
    if (devices[i].dname === dname)
      devices.splice(i, 1);
  }
};

//params - dname: dname to be sent data to
//returns -
//functionality - forces a device to send data to the server,
//                the device has to respond to {"event":"sendData","data":{}}
var forceDeviceToSendData = function(dname) {
  var ip = getIpForDname(dname);

  var obj = {
    event: "sendData",
    data: {}
  };
  controllerWSS.sendToClient(ip, JSON.stringify(obj));
  //flog('forced device ' + dname + ' to send data', 'INFO'); too much log data
}

//params - dname: device on which the command should be executed
//         command: the command that should be sent
//returns -
//functionality - forces a device to execute a command without a configuration
var forceDeviceToExecuteCommand = function(dname, command) {
  var ip = getIpForDname(dname);
  if (ip === -1) {
    flog('couldn\'t find device' + dname + ' to force execute command',
      'ERROR');
    return;
  }
  var obj = {
    event: "action",
    data: command
  }
  controllerWSS.sendToClient(ip, JSON.stringify(obj));
  flog('forced device ' + dname + ' to execute command ' + command, 'INFO');
};

//params - dname: device to be check
//returns - true if device is already registered, false if it is not registered
//functionality - looks for possible matches in the devices array
var isDeviceAlreadyRegistered = function(dname) {
  for (var i = 0; i < devices.length; i++) {
    if (devices[i].dname === dname)
      return true;
  }
  return false;
};

//params - dname
//returns -
//functionality - puts a timestamp with the current date onto the specified device
var putTimeStampOnDevice = function(dname) {
  for (var i = 0; i < devices.length; i++) {
    if (devices[i].dname === dname) {
      devices[i].timestamp = new Date();
    }
  }
};

//params - dname: device to be saved to, data: data which should be saved
//returns -
//functionality - to use configurations accordingly, the data latest received
//                has to be stored with the device; this method does this
var saveDataAsLatestValueToDevice = function(dname, data) {
  for (var i = 0; i < devices.length; i++) {
    if (devices[i].dname === dname) {
      devices[i].latestValue = data;
      return;
    }
  }
  return;
};

//params - dname: device value to be found
//returns - latest value of the specified device
//functionality - searches the latest value for the specified dname and
//                returns it
var getLatestValueForDevice = function(dname) {
  for (var i = 0; i < devices.length; i++) {
    if (devices[i].dname === dname) {
      return devices[i].latestValue;
    }
  }
  return null;
};

//params - ip: ip to be found
//returns - the dname which matches the ip
//functionality - looks for the ip in the devices array and returns it
var getDnameByIp = function(ip) {
  for (var i = 0; i < devices.length; i++) {
    if (devices[i].ip === ip)
      return devices[i].dname;
  }
  return -1;
}

//params - dname: device to be found
//returns - device type
//functionality - looks for type of specified dname and returns it
var getTypeForDevice = function(dname) {
  for (var i = 0; i < devices.length; i++) {
    if (devices[i].dname === dname) return devices[i].type;
  }
};

//params - dname: device to be found
//returns - device type
//functionality - looks for type of specified dname and returns it
var getCategoryForDevice = function(dname) {
  for (var i = 0; i < devices.length; i++) {
    if (devices[i].dname === dname) return devices[i].category;
  }
};

//------------------------- DATAFORWARDING -------------------------
//initialize dataDict which contains the forwarding data
//the userDict has attributes "to" and "dname"
//when data from a device reaches the server it is saved in the userDict
//which ip wants that data to be forwarded to
var userDict = [];
var latestValuesDict = [];

//params - ip: ip to be found
//returns - index at which it was found
//functionality - searches the userDict for a possible ip match and returns that index if found
var findUserEntry = function(ip) {
  for (var i = 0; i < userDict.length; i++) {
    if (userDict[i].to === ip) return i;
  }
  return -1;
};

//params - dname: dname for which ips should be found
//returns - array of ips which match dname
//functionality - searches the userDict for possible matches and returns those ips
var findIpsForDeviceName = function(dname) {

  var res = [];

  for (var i = 0; i < userDict.length; i++) {
    if (userDict[i].dname === dname) {
      res.push(userDict[i].to);
    }
  }

  return res;
};

//params - message: message to be checked for forwarding
//returns -
//functionality - looks up in the userDict if any ip wants data from this message
//                and forwards it accordingly
var checkAndSendData = function(message) {
  var ips = findIpsForDeviceName(message.dname);
  for (var i = 0; i < ips.length; i++) {
    dataWSS.sendToClient(ips[i], JSON.stringify(message));
    flog('forwarded data from device ' + message.dname + ' to ' + ips[i],
      'INFO');
  }
};

//params -
//returns -
//functionality - sends the latest devices (with latest values)
//                to the users who registered in latestValuesDict
var sendLatestValues = function() {
  for (var i = 0; i < latestValuesDict.length; i++) {
    var obj = {
      devices: devices
    }
    dataWSS.sendToClient(latestValuesDict[i], JSON.stringify(obj));
  }
}

//------------------------- DATAHISTORY DATABASE -------------------------
//initializing database
var exists = fs.existsSync(DATABASE_PATH);
var sqlite3 = require("sqlite3").verbose();
var db = new sqlite3.Database(DATABASE_PATH);

//initializes the database if it does not already exist
db.serialize(function() {
  if (!exists) {
    db.run(
      "CREATE TABLE DATA (DNAME TEXT NOT NULL, VALUE TEXT, DATE TEXT NOT NULL);"
    );
    flog('created database for datahistory', 'INFO');
  }
});

//params - dname: dname for the entry, value: value to be saved
//returns -
//functionality - saves dname and value with a timestamp into the database
var writeDataToDb = function(dname, value) {

  db.serialize(function() {


    var stmt = db.prepare("INSERT INTO DATA VALUES(?,?,?);");

    stmt.run(dname, value, new Date().getTime());

    stmt.finalize();
  });

  //not logging here since the data is in the database anyways
};

//params - dname: dname to search historyData for, ip: to which ip the historyData gets sent
//returns -
//functionality - gets all historyDataEntries from the db and sends them to the specified ip
var sendHistoryDataToClientByDname = function(dname, ip) {
  var res = [];
  db.serialize(function() {
    db.all('SELECT value, date from DATA where DNAME = \'' + dname +
      '\';',
      function(err, rows) {
        rows.forEach(function(row) {
          var tmp = row;
          if (tmp.VALUE == 1) {
            tmp.value = true;
          } else {
            tmp.value = false;
          }
          delete tmp.VALUE;

          tmp.date = tmp.DATE;
          delete tmp.DATE;
          res.push(tmp);
        })

        var obj = {
          dname: dname,
          historyData: res
        }

        dataWSS.sendToClient(ip, JSON.stringify(obj));
        flog("sent historyData to " + ip, "INFO");
      });
  });
};

//------------------------- DATE -------------------------
//params - d1: date 1, d2: date 2
//returns - differnce in seconds between the two dates
//functionality - calculates the difference between the two dates and returns it
//                in seconds
var getDateDiffInSeconds = function(d1, d2) {
  var diff = d1.getTime() - d2.getTime();
  return diff / 1000;
};

//params - cnd: current condition
//returns - true/false
//functionality - checks if the current date is lesser or great than the date
//                specified in the given condition
var checkTime = function(cnd) {
  var currDate = new Date();
  var checkDate = new Date();
  checkDate.setHours(cnd.value.split(":")[0]);
  checkDate.setMinutes(cnd.value.split(":")[1]);
  checkDate.setSeconds(0);
  return applyMod(currDate, checkDate, cnd.mod);
};

//------------------------- WEBSOCKETS -------------------------

//------------------------- CONTROLLER-WSS -------------------------

//the controllerWSS handles all interaction between devices (sensors/actors)
controllerWSS.on('connection', function connection(ws) {
  flog("connection on controllerWSS " + ws._socket.remoteAddress,
    "INFO");
  ws.on('message', function incoming(message) {
    var pkg = JSON.parse(message);
    pkg.from = ws._socket.remoteAddress;
    pkg.dname = pkg.dname;
    processCommand(pkg);
  });
  //if a device sends a close command it gets deleted from the device list
  ws.on('close', function() {
    flog("device " + getDnameByIp(ws._socket.remoteAddress) +
      " was manually disconnected from the server",
      "ERROR");
    deleteDeviceByDname(getDnameByIp(ws._socket.remoteAddress));
  });
  ws.send('connected');
});

//params - address: address to be sent to, data: data to be sent
//returns -
//functionality - sends the specified data to the specified address
controllerWSS.sendToClient = function sendToClient(address, data) {
  controllerWSS.clients.forEach(function each(client) {
    if (client._socket.remoteAddress === address) {
      client.send(data);
    }
  });
};

//params - cmd: the command to be proccessed
//returns -
//functionality - proccesses the command and takes actions based on it's data
var processCommand = function(cmd) {
  //if the event is regDevice a new device will be added to the devices array
  if (cmd.event === "regDevice") {

    //check if dname is already taken
    if (isDeviceAlreadyRegistered(cmd.dname)) {
      controllerWSS.sendToClient(cmd.from, JSON.stringify({
        event: "error",
        data: "dname already registered"
      }));
      flog('device ' + cmd.dname +
        ' could not be registered, dname already registeres', 'ERROR');
    } else {
      devices.push({
        type: cmd.type,
        category: cmd.category,
        dname: cmd.dname,
        values: cmd.values,
        ip: cmd.from,
        latestValue: null,
        timestamp: new Date()
      });
      flog('added new device ' + cmd.dname + ' to devices array', 'INFO');
    }
    //if the event is not regDevice it is regular data from the device and will be
    //handled accordingly
  } else {
    //puts the current timestamp on the device to check if it is disconnected
    putTimeStampOnDevice(cmd.dname);
    //only data from sensors will be considered with the next functions
    if (getCategoryForDevice(cmd.dname) === 'sensor') {
      //put the received data into the database
      writeDataToDb(cmd.dname, cmd.data);
      //save the data as the latest received value
      saveDataAsLatestValueToDevice(cmd.dname, cmd.data);
      //checks if a device has registered this data source (in the userDict)
      //and sends data to it
      checkAndSendData(cmd);
      //checks configurations and sends possible execute commands
      checkConfigurations(cmd);
    }
  }
};

//params - value1: first value, value2: second value, mod: modifier to apply
//returns - value1 mod value2 (e.g. 5 >= 2)
//functionality - applies boolean operators for specified mod to values 1 and 2
var applyMod = function(value1, value2, mod) {
  if (mod === "greater")
    return value1 >= value2;
  if (mod === "lesser")
    return value1 <= value2;
};


//params - value: value which the operators should be applied to
//         flag: the current flag
//         operator: which operator should be applied (as a string (and/or))
//returns - true/false
//functionality - applies an boolean operator to two values and returns the result
var applyLogicalOperator = function(value, flag, operator) {
  if (operator === "and")
    return value && flag;
  if (operator === "or")
    return value || flag;
  else
    return false;
};


//params -
//returns -
//functionality - checks if any conditions in configurations are met; if they are
//                a specified command will be sent to the specified actor
var checkConfigurations = function() {
  var flag = false;
  for (var i = 0; i < configurations.length; i++) {
    var config = configurations[i];
    for (var j = 0; j < configurations[i].conditions.length; j++) {

      var cnd = configurations[i].conditions[j];

      if (getTypeForDevice(cnd.dname) === "time") {
        //if it's the first condition the flag is the value
        if (j != 0) {
          flag = applyLogicalOperator(checkTime(cnd), flag, config.logicalOperator);
        } else {
          flag = checkTime(cnd);
        }
      }

      if (getTypeForDevice(cnd.dname) === "button") {

        if (cnd.value === getLatestValueForDevice(cnd.dname)) {
          var val = true;
        } else {
          var val = false;
        }

        //if it's the first condition the flag is the value
        if (j != 0) {
          flag = applyLogicalOperator(val, flag, config.logicalOperator);
        } else {
          flag = val;
        }

      }

      if (getTypeForDevice(cnd.dname) === "temperature") {

        var val = applyMod(getLatestValueForDevice(cnd.dname), cnd.value,
          cnd
          .mod);

        //if it's the first condition the flag is the value
        if (j != 0) {
          flag = applyLogicalOperator(val, flag, config.logicalOperator);
        } else {
          flag = val;
        }

      }
    }


    //if the flag is true, the configurated action will be sent to the target device
    if (flag) {
      if (getIpForDname(config.dname) === -1) {
        flog('target device not found ' + config.dname, "ERROR");
      } else {
        flog('sent action ' + config.action + ' to ' + getIpForDname(
            config.dname),
          "INFO");
        var act = config.action;
        if (act === "on")
          act = true;
        if (act === "off")
          act = false;
        var obj = {
          event: "action",
          data: act
        }
        controllerWSS.sendToClient(getIpForDname(config.dname),
          JSON.stringify(obj));
      }

    }

    flag = false;
  }

};


//------------------------- DATA-WSS -------------------------

//the dataWSS handles all interaction between clients (Webbrowser, Android-Phone)
dataWSS.on('connection', function connection(ws) {
  flog("connection on dataWSS " + ws._socket.remoteAddress, "INFO");
  ws.on('message', function incoming(message) {
    var msg = JSON.parse(message);

    //if the event is "setDevice" is called it means that the caller ip wants to
    //receive all data which is sent by the specified dname
    if (msg.event === "setDevice") {

      //checks if caller ip already has an entry since only one data source can
      //be forwarded from (e.g. My Android-Phone can only receive data from one
      //device at a time)
      if (findUserEntry(ws._socket.remoteAddress) != -1) {
        userDict.splice(findUserEntry(ws._socket.remoteAddress),
          1);
      }

      //adds the new forward to the userDict
      userDict.push({
        to: ws._socket.remoteAddress,
        dname: msg.data
      });
    }

    //sends devices to caller
    if (msg.event === "getDevices") {
      var obj = {
        devices: devices
      }
      dataWSS.sendToClient(ws._socket.remoteAddress,
        JSON.stringify(obj));
    }

    //adds a new configuration and sends it to the caller
    if (msg.event === "newConfiguration") {
      if (configNameAlreadyExists(msg.data.cname)) {
        dataWSS.sendToClient(ws._socket.remoteAddress, JSON.stringify({
          event: "error",
          data: "configuration name already exists"
        }));

      }

      addConfiguration(msg.data);
      var obj = {
        configurations: configurations
      }

      dataWSS.sendToClient(ws._socket.remoteAddress, JSON.stringify(
        obj));
    }

    //delets a configuration and sends the new list to the caller
    if (msg.event === "deleteConfiguration") {
      deleteConfiguration(msg.data.cname);

      var obj = {
        configurations: configurations
      }

      dataWSS.sendToClient(ws._socket.remoteAddress, JSON.stringify(
        obj));

    }

    //sends all configurations to the caller
    if (msg.event === "getConfigurations") {
      var obj = {
        configurations: configurations
      }
      dataWSS.sendToClient(ws._socket.remoteAddress, JSON.stringify(
        obj));
      flog('sent configurations to ' + ws._socket.remoteAddress, 'INFO');
    }

    //edits the configuration and sends configurations to caller
    if (msg.event === "editConfiguration") {
      var obj = msg.data;
      //delete generated attribute from angular's ng-repeat
      delete obj.$$hashKey;
      editConfiguration(obj.cname, obj);
      var obj2 = {
        configurations: configurations
      }

      dataWSS.sendToClient(ws._socket.remoteAddress, JSON.stringify(
        obj2));
    }

    //sends the historydata for the specified dname to the caller
    if (msg.event === "getHistoryDataByDname") {
      sendHistoryDataToClientByDname(msg.data.dname, ws._socket.remoteAddress);
    }

    //the client has to have the device registered in the userDict
    //for this to work that means first call setDevice then call
    //forceDeviceToSendData from the client to receive the current data
    if (msg.event === "forceDeviceToSendData") {
      forceDeviceToSendData(msg.data.dname)
    }

    //sends the specified command to the specified device
    //occurs when a user wants to directly command a device
    if (msg.event === "forceDeviceToExecuteCommand") {
      forceDeviceToExecuteCommand(msg.data.dname, msg.data.action);
    }

    if (msg.event === "subscribeLatestData") {
      //checks if it is already subscribed
      var flag = false;
      for (var i = 0; i < latestValuesDict.length; i++) {
        if (latestValuesDict[i] == ws._socket.remoteAddress)
          flag = true;
      }
      if (!flag)
        latestValuesDict.push(ws._socket.remoteAddress);
    }

  });

  ws.send('connected');
});

//params - address: address to be sent to, data: data to be sent
//returns -
//functionality - sends the specified data to the specified address
dataWSS.sendToClient = function sendToClient(address, data) {
  dataWSS.clients.forEach(function each(client) {
    if (client._socket.remoteAddress === address) {
      client.send(data);
    }
  });
};



//checks if all clients are still connected and fires the checkConfigurations for time changes
setInterval(function() {
  checkConfigurations();
  sendLatestValues();
  //starts at 1 because time-"device" will not be included
  for (var i = 1; i < devices.length; i++) {
    forceDeviceToSendData(devices[i].dname);
    if (getDateDiffInSeconds(new Date(), devices[i].timestamp) >
      AUTOMATIC_DISCONNECT_DEVICE_TIME) {
      flog("device " + devices[i].dname +
        " was automatically timed out",
        "ERROR");
      deleteDeviceByDname(devices[i].dname);
    }
  }

}, TIMER_INTERVAL_FORCE_DATA);
